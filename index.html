<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Reaction Timer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Space+Grotesk:wght@700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: #0F172A;
            color: #F8FAFC;
            overflow: hidden;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-overlay {
            position: relative;
            z-index: 10;
            text-align: center;
            padding: 2rem;
            max-width: 600px;
            width: 100%;
        }

        h1 {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 3rem;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #06B6D4 0%, #10B981 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.02em;
        }

        .instruction {
            font-size: 1.25rem;
            color: #CBD5E1;
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        #game-area {
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(6, 182, 212, 0.2);
            border-radius: 1.5rem;
            padding: 3rem 2rem;
            min-height: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        #game-area:hover {
            border-color: rgba(6, 182, 212, 0.4);
            transform: translateY(-2px);
        }

        #game-area.waiting {
            border-color: rgba(251, 191, 36, 0.3);
            background: rgba(30, 41, 59, 0.8);
        }

        #game-area.ready {
            border-color: rgba(16, 185, 129, 0.6);
            background: rgba(16, 185, 129, 0.1);
            animation: pulse 0.5s ease-in-out;
        }

        #game-area.early {
            border-color: rgba(239, 68, 68, 0.6);
            background: rgba(239, 68, 68, 0.1);
            animation: shake 0.5s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .status-text {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }

        .status-text.waiting {
            color: #FBB936;
        }

        .status-text.ready {
            color: #10B981;
            font-size: 3rem;
        }

        .status-text.early {
            color: #EF4444;
        }

        .reaction-time {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 4rem;
            color: #06B6D4;
            margin: 1rem 0;
            text-shadow: 0 0 20px rgba(6, 182, 212, 0.5);
        }

        .unit {
            font-size: 1.5rem;
            color: #94A3B8;
            margin-left: 0.5rem;
        }

        .stats {
            display: flex;
            gap: 2rem;
            justify-content: center;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .stat-item {
            background: rgba(15, 23, 42, 0.5);
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            border: 1px solid rgba(6, 182, 212, 0.2);
        }

        .stat-label {
            font-size: 0.875rem;
            color: #94A3B8;
            margin-bottom: 0.25rem;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #F8FAFC;
        }

        button {
            background: linear-gradient(135deg, #06B6D4 0%, #0891B2 100%);
            color: #F8FAFC;
            border: none;
            padding: 1rem 2.5rem;
            font-size: 1.125rem;
            font-weight: 600;
            border-radius: 0.75rem;
            cursor: pointer;
            margin-top: 1.5rem;
            transition: all 0.3s ease;
            font-family: 'Inter', sans-serif;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(6, 182, 212, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .hint {
            font-size: 0.875rem;
            color: #64748B;
            margin-top: 1rem;
            font-style: italic;
        }

        @media (max-width: 640px) {
            h1 {
                font-size: 2rem;
            }

            .instruction {
                font-size: 1rem;
            }

            #game-area {
                padding: 2rem 1rem;
                min-height: 250px;
            }

            .status-text {
                font-size: 1.5rem;
            }

            .status-text.ready {
                font-size: 2rem;
            }

            .reaction-time {
                font-size: 3rem;
            }

            .stats {
                gap: 1rem;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="ui-overlay">
        <h1>âš¡ Reaction Timer</h1>
        <p class="instruction">Test your reaction speed with an immersive 3D experience</p>
        
        <div id="game-area">
            <div id="content">
                <div class="status-text">Click to Start</div>
                <p class="hint">Click anywhere when the signal appears</p>
            </div>
        </div>

        <button id="reset-btn" style="display: none;">Play Again</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ===== GAME STATE MANAGEMENT =====
        // Centralized state management for clean architecture
        const GameState = {
            current: 'idle', // idle, waiting, ready, early, result
            startTime: null,
            reactionTime: null,
            timeoutId: null,
            attempts: 0,
            totalTime: 0,
            bestTime: null,

            setState(newState) {
                this.current = newState;
                UIManager.update();
                SceneManager.updateForState(newState);
            },

            recordReaction(time) {
                this.reactionTime = time;
                this.attempts++;
                this.totalTime += time;
                if (this.bestTime === null || time < this.bestTime) {
                    this.bestTime = time;
                }
            },

            getAverageTime() {
                return this.attempts > 0 ? Math.round(this.totalTime / this.attempts) : 0;
            },

            reset() {
                if (this.timeoutId) {
                    clearTimeout(this.timeoutId);
                    this.timeoutId = null;
                }
                this.startTime = null;
                this.reactionTime = null;
            }
        };

        // ===== THREE.JS SCENE MANAGEMENT =====
        // Handles all 3D graphics and animations
        const SceneManager = {
            scene: null,
            camera: null,
            renderer: null,
            shapes: [],
            particles: [],
            lights: {},
            animationId: null,

            init() {
                // Setup scene
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x0F172A, 10, 50);

                // Setup camera with slight perspective
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.z = 15;

                // Setup renderer with alpha for transparency
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setClearColor(0x0F172A, 0);
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                // Create ambient lighting
                this.lights.ambient = new THREE.AmbientLight(0xffffff, 0.4);
                this.scene.add(this.lights.ambient);

                // Create dynamic point lights
                this.lights.point1 = new THREE.PointLight(0x06B6D4, 1, 50);
                this.lights.point1.position.set(10, 10, 10);
                this.scene.add(this.lights.point1);

                this.lights.point2 = new THREE.PointLight(0x10B981, 0.8, 50);
                this.lights.point2.position.set(-10, -10, 10);
                this.scene.add(this.lights.point2);

                // Create 3D shapes for idle state
                this.createIdleShapes();

                // Handle window resize
                window.addEventListener('resize', () => this.onResize());

                // Start animation loop
                this.animate();
            },

            createIdleShapes() {
                // Clear existing shapes
                this.shapes.forEach(shape => this.scene.remove(shape));
                this.shapes = [];

                // Create floating geometric shapes
                const geometries = [
                    new THREE.IcosahedronGeometry(1.5, 0),
                    new THREE.OctahedronGeometry(1.5, 0),
                    new THREE.TorusGeometry(1, 0.4, 16, 100)
                ];

                const positions = [
                    { x: -4, y: 2, z: 0 },
                    { x: 4, y: -2, z: -2 },
                    { x: 0, y: 0, z: -4 }
                ];

                geometries.forEach((geometry, i) => {
                    const material = new THREE.MeshPhongMaterial({
                        color: 0x06B6D4,
                        shininess: 100,
                        transparent: true,
                        opacity: 0.6,
                        wireframe: false
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(positions[i].x, positions[i].y, positions[i].z);
                    mesh.userData.rotationSpeed = { x: 0.005, y: 0.01, z: 0.005 };
                    mesh.userData.floatSpeed = 0.5 + Math.random() * 0.5;
                    mesh.userData.floatOffset = Math.random() * Math.PI * 2;
                    
                    this.shapes.push(mesh);
                    this.scene.add(mesh);
                });
            },

            createReadySignal() {
                // Clear existing shapes
                this.shapes.forEach(shape => this.scene.remove(shape));
                this.shapes = [];

                // Create large central sphere that pulses
                const geometry = new THREE.SphereGeometry(3, 32, 32);
                const material = new THREE.MeshPhongMaterial({
                    color: 0x10B981,
                    emissive: 0x10B981,
                    emissiveIntensity: 0.5,
                    shininess: 100,
                    transparent: true,
                    opacity: 0
                });

                const sphere = new THREE.Mesh(geometry, material);
                sphere.userData.targetOpacity = 1;
                sphere.userData.pulseSpeed = 2;
                
                this.shapes.push(sphere);
                this.scene.add(sphere);

                // Create particle burst effect
                this.createParticles();

                // Animate lights to green
                this.animateLightColor(this.lights.point1, 0x10B981);
                this.animateLightColor(this.lights.point2, 0x10B981);
            },

            createParticles() {
                // Clear existing particles
                this.particles.forEach(particle => this.scene.remove(particle));
                this.particles = [];

                // Create particle system for burst effect
                const particleCount = 50;
                const geometry = new THREE.BufferGeometry();
                const positions = [];

                for (let i = 0; i < particleCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const radius = 2;

                    positions.push(
                        radius * Math.sin(phi) * Math.cos(theta),
                        radius * Math.sin(phi) * Math.sin(theta),
                        radius * Math.cos(phi)
                    );
                }

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

                const material = new THREE.PointsMaterial({
                    color: 0x10B981,
                    size: 0.2,
                    transparent: true,
                    opacity: 1
                });

                const particles = new THREE.Points(geometry, material);
                particles.userData.velocities = [];
                
                for (let i = 0; i < particleCount; i++) {
                    particles.userData.velocities.push({
                        x: (Math.random() - 0.5) * 0.2,
                        y: (Math.random() - 0.5) * 0.2,
                        z: (Math.random() - 0.5) * 0.2
                    });
                }

                this.particles.push(particles);
                this.scene.add(particles);
            },

            animateLightColor(light, targetColor) {
                // Smooth color transition for lights
                const startColor = light.color.clone();
                const endColor = new THREE.Color(targetColor);
                const duration = 500;
                const startTime = Date.now();

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    light.color.lerpColors(startColor, endColor, progress);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };

                animate();
            },

            updateForState(state) {
                switch (state) {
                    case 'idle':
                        this.createIdleShapes();
                        this.animateLightColor(this.lights.point1, 0x06B6D4);
                        this.animateLightColor(this.lights.point2, 0x10B981);
                        break;
                    case 'waiting':
                        this.animateLightColor(this.lights.point1, 0xFBB936);
                        this.animateLightColor(this.lights.point2, 0xFBB936);
                        break;
                    case 'ready':
                        this.createReadySignal();
                        break;
                    case 'early':
                        this.animateLightColor(this.lights.point1, 0xEF4444);
                        this.animateLightColor(this.lights.point2, 0xEF4444);
                        break;
                }
            },

            animate() {
                this.animationId = requestAnimationFrame(() => this.animate());

                const time = Date.now() * 0.001;

                // Animate shapes based on current state
                this.shapes.forEach((shape, index) => {
                    // Rotation
                    if (shape.userData.rotationSpeed) {
                        shape.rotation.x += shape.userData.rotationSpeed.x;
                        shape.rotation.y += shape.userData.rotationSpeed.y;
                        shape.rotation.z += shape.userData.rotationSpeed.z;
                    }

                    // Floating animation
                    if (shape.userData.floatSpeed) {
                        const offset = shape.userData.floatOffset || 0;
                        shape.position.y += Math.sin(time * shape.userData.floatSpeed + offset) * 0.01;
                    }

                    // Fade in ready signal
                    if (shape.userData.targetOpacity !== undefined && shape.material.opacity < shape.userData.targetOpacity) {
                        shape.material.opacity = Math.min(shape.material.opacity + 0.05, shape.userData.targetOpacity);
                    }

                    // Pulse effect for ready state
                    if (shape.userData.pulseSpeed && GameState.current === 'ready') {
                        const scale = 1 + Math.sin(time * shape.userData.pulseSpeed) * 0.1;
                        shape.scale.set(scale, scale, scale);
                    }
                });

                // Animate particles
                this.particles.forEach(particleSystem => {
                    if (particleSystem.userData.velocities) {
                        const positions = particleSystem.geometry.attributes.position.array;
                        particleSystem.userData.velocities.forEach((vel, i) => {
                            positions[i * 3] += vel.x;
                            positions[i * 3 + 1] += vel.y;
                            positions[i * 3 + 2] += vel.z;
                        });
                        particleSystem.geometry.attributes.position.needsUpdate = true;
                        particleSystem.material.opacity *= 0.98;
                    }
                });

                // Rotate camera slightly for depth
                this.camera.position.x = Math.sin(time * 0.1) * 2;
                this.camera.lookAt(this.scene.position);

                this.renderer.render(this.scene, this.camera);
            },

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            },

            destroy() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                this.renderer.dispose();
            }
        };

        // ===== UI MANAGER =====
        // Handles all UI updates based on game state
        const UIManager = {
            elements: {
                gameArea: document.getElementById('game-area'),
                content: document.getElementById('content'),
                resetBtn: document.getElementById('reset-btn')
            },

            update() {
                const state = GameState.current;
                
                // Update game area classes
                this.elements.gameArea.className = '';
                if (state === 'waiting') this.elements.gameArea.classList.add('waiting');
                if (state === 'ready') this.elements.gameArea.classList.add('ready');
                if (state === 'early') this.elements.gameArea.classList.add('early');

                // Update content based on state
                switch (state) {
                    case 'idle':
                        this.showIdle();
                        break;
                    case 'waiting':
                        this.showWaiting();
                        break;
                    case 'ready':
                        this.showReady();
                        break;
                    case 'early':
                        this.showEarly();
                        break;
                    case 'result':
                        this.showResult();
                        break;
                }
            },

            showIdle() {
                this.elements.content.innerHTML = `
                    <div class="status-text">Click to Start</div>
                    <p class="hint">Click anywhere when the signal appears</p>
                `;
                this.elements.resetBtn.style.display = 'none';
            },

            showWaiting() {
                this.elements.content.innerHTML = `
                    <div class="status-text waiting">Wait for it...</div>
                    <p class="hint">Don't click yet!</p>
                `;
                this.elements.resetBtn.style.display = 'none';
            },

            showReady() {
                this.elements.content.innerHTML = `
                    <div class="status-text ready">CLICK NOW!</div>
                `;
                this.elements.resetBtn.style.display = 'none';
            },

            showEarly() {
                this.elements.content.innerHTML = `
                    <div class="status-text early">Too Early!</div>
                    <p class="hint">Wait for the green signal</p>
                `;
                this.elements.resetBtn.style.display = 'block';
            },

            showResult() {
                const time = GameState.reactionTime;
                const avg = GameState.getAverageTime();
                const best = GameState.bestTime;

                // Rating system for feedback
                let rating = '';
                let ratingColor = '';
                if (time < 200) {
                    rating = 'Lightning Fast! âš¡';
                    ratingColor = '#10B981';
                } else if (time < 300) {
                    rating = 'Excellent! ðŸŽ¯';
                    ratingColor = '#06B6D4';
                } else if (time < 400) {
                    rating = 'Good! ðŸ‘';
                    ratingColor = '#10B981';
                } else {
                    rating = 'Keep practicing! ðŸ’ª';
                    ratingColor = '#FBB936';
                }

                this.elements.content.innerHTML = `
                    <div style="color: ${ratingColor}; font-size: 1.5rem; font-weight: 700; margin-bottom: 1rem;">
                        ${rating}
                    </div>
                    <div class="reaction-time">
                        ${time}<span class="unit">ms</span>
                    </div>
                    <div class="stats">
                        <div class="stat-item">
                            <div class="stat-label">Average</div>
                            <div class="stat-value">${avg}ms</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Best</div>
                            <div class="stat-value">${best}ms</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Attempts</div>
                            <div class="stat-value">${GameState.attempts}</div>
                        </div>
                    </div>
                `;
                this.elements.resetBtn.style.display = 'block';
            }
        };

        // ===== GAME CONTROLLER =====
        // Manages game logic and user interactions
        const GameController = {
            init() {
                // Initialize Three.js scene
                SceneManager.init();

                // Setup event listeners
                this.elements.gameArea.addEventListener('click', () => this.handleClick());
                this.elements.resetBtn.addEventListener('click', () => this.startGame());

                // Initial UI state
                UIManager.update();
            },

            elements: UIManager.elements,

            startGame() {
                GameState.reset();
                GameState.setState('waiting');

                // Random delay between 1-5 seconds to prevent pattern memorization
                const delay = 1000 + Math.random() * 4000;
                
                GameState.timeoutId = setTimeout(() => {
                    if (GameState.current === 'waiting') {
                        GameState.startTime = performance.now();
                        GameState.setState('ready');
                    }
                }, delay);
            },

            handleClick() {
                switch (GameState.current) {
                    case 'idle':
                        this.startGame();
                        break;
                    
                    case 'waiting':
                        // Penalize early clicks
                        GameState.reset();
                        GameState.setState('early');
                        break;
                    
                    case 'ready':
                        // Calculate reaction time with high precision
                        const reactionTime = Math.round(performance.now() - GameState.startTime);
                        GameState.recordReaction(reactionTime);
                        GameState.setState('result');
                        break;
                    
                    case 'early':
                    case 'result':
                        // These states are handled by reset button
                        break;
                }
            }
        };

        // ===== INITIALIZATION =====
        // Start the application when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => GameController.init());
        } else {
            GameController.init();
        }
    </script>
</body>
</html>